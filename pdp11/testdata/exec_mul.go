// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"strings"
)

var ops = []string{
	"ashc",
	"ashc1",
	"div",
	"mul",
	"mul1",
}

var vals = []uint16{
	0,
	1,
	2,
	0o177,
	0o200,
	0o377,
	0o400,
	0o070707,
	0o077777,
	0o100000,
	0o177776,
	0o177777,
}

func main() {
	for _, op := range ops {
		var b bytes.Buffer
		fmt.Fprintf(&b, "// generated by go run exec_mul.go\n\n")
		for _, r0 := range vals {
			for _, r1 := range vals {
				for _, r2 := range vals {
					r0 := r0
					r1 := r1
					fmt.Fprintf(&b, "mov #%06o, r0\nmov #%06o, r1\nmov #%06o, r2\nccc\n", r0, r1, r2)
					if op == "ashc1" || op == "mul1" {
						fmt.Fprintf(&b, "%s r2, r1\n", strings.TrimSuffix(op, "1"))
					} else {
						fmt.Fprintf(&b, "%s r2, r0\n", op)
					}
					n, z, v, c := false, false, false, false

					switch op {
					case "ashc", "ashc1":
						w := uint32(r0)<<16 | uint32(r1)
						if op == "ashc1" {
							w = uint32(r1)<<16 | uint32(r1)
						}
						sh := int16(r2) << 10 >> 10
						ow := w
						if sh < 0 {
							w = uint32(int32(ow) >> -sh)
							c = (ow>>(-sh-1))&1 != 0
						} else if sh > 0 {
							w <<= sh
							c = (ow<<(sh-1))>>31 != 0
						} else {
							c = false
						}
						n, z, v = int32(w) < 0, w == 0, (int32(w) < 0) != (int32(ow) < 0)
						if op == "ashc" {
							r0 = uint16(w >> 16)
						}
						r1 = uint16(w)

					case "div":
						if r2 == 0 {
							// divide by zero sets Z = C = V = 1
							// verified by CKEBFF0
							z, c, v = true, true, true
							break
						}
						top := int32(r0)<<16 | int32(r1)
						q, rem := top/int32(int16(r2)), top%int32(int16(r2))
						r0 = uint16(q)
						r1 = uint16(rem)
						n, z, v, c = q < 0, q == 0, int32(int16(q)) != q, false

					case "mul", "mul1":
						var u int32
						if op == "mul" {
							u = int32(int16(r0)) * int32(int16(r2))
							r0 = uint16(u >> 16)
							r1 = uint16(u)
						} else {
							u = int32(int16(r1)) * int32(int16(r2))
							r1 = uint16(u)
						}
						n, z, v, c = u < 0, u == 0, false, false // TODO int32(int16(u)) != u
					}
					fmt.Fprintf(&b, "now")
					if r0 != 0 {
						fmt.Fprintf(&b, " r0=%06o", r0)
					}
					if r1 != 0 {
						fmt.Fprintf(&b, " r1=%06o", r1)
					}
					if r2 != 0 {
						fmt.Fprintf(&b, " r2=%06o", r2)
					}
					if n || z || v || c {
						fmt.Fprintf(&b, " nzvc=%d%d%d%d", bit(n), bit(z), bit(v), bit(c))
					}
					if r0 == 0 && r1 == 0 && r2 == 0 && !n && !z && !v && !c {
						fmt.Fprintf(&b, " ~")
					}
					fmt.Fprint(&b, "\n")
				}
			}
		}

		if err := os.WriteFile("exec_"+op+".txt", b.Bytes(), 0666); err != nil {
			log.Fatal(err)
		}
	}
}

func bit(b bool) uint16 {
	if b {
		return 1
	}
	return 0
}
